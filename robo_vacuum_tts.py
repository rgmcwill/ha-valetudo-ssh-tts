import sys, logging, json, ipaddress, pathlib, configparser, argparse
import urllib.parse
import urllib.request
import paramiko.client

# constants
TTS_URL_ENDPOINT = "api/tts_get_url"
TEMP_AUDIO_FILE = "/tmp/tts.wav"

# methods
def is_valid_url(url):
    try:
        return all([url.scheme, url.netloc])
    except ValueError:
        return False

def is_valid_ip(ip):
    try:
        ipaddress.ip_address(ip)
        return True
    except ValueError:
        return False

def is_valid_file_path(file_path):
    try:
        path = pathlib.Path(file_path)
        # Check if the path exists and is a file
        return path.is_file()
    except Exception:
        return False

config = configparser.ConfigParser()
config.read('config.ini')

parser = argparse.ArgumentParser(description='Has robot vacuum play tts generated audio files from home assistant')
parser.add_argument('-i', action='store_true',
                    help='determines if the script is run in interactive mode. If so it will prop the user for input, play the input as a message and repeat until terminated via Ctrl-C')
parser.add_argument('--token', required=(False if (config.get('Settings', 'homeassistant_token')) else True), default=config.get('Settings', 'homeassistant_token'),
                    help='the bearer token generated by your home assistant instance (default: will use the \'homeassistant_token\' setting in the config.ini file)') 
parser.add_argument('--message', default="Hello",
                    help='the message to be read by the robot. This option will be ignored by if the -i argument is provided (default: Hello)')

args = vars(parser.parse_args())

MESSAGE = args.get('message')
HOMEASSISTANT_BASE_URL = config.get('Settings', 'homeassistant_url')
BEARER_TOKEN = args.get('token')
ROBO_VACCUM_IP = config.get('Settings', 'robot_ip')
ROBO_VACCUM_SSH_KEY_PATH = config.get('Settings', 'robot_ssh_key_path')
INTERACTIVE_MODE = args.get('i')

# no need to check 1st arg
# check 2nd arg
homeassistant_url = urllib.parse.urlparse(HOMEASSISTANT_BASE_URL + ('' if HOMEASSISTANT_BASE_URL[-1] == '/' else '/') + TTS_URL_ENDPOINT)
if (not is_valid_url(homeassistant_url)):
    logging.error("The provided url is invalid: {}".format(homeassistant_url))
    exit()

# no need to check 3rd arg
# check 4th arg
if (not is_valid_ip(ROBO_VACCUM_IP)):
    logging.error("The provided ip is invalid: {}".format(ROBO_VACCUM_IP))
    exit()

# check 5th arg
if (not is_valid_file_path(ROBO_VACCUM_SSH_KEY_PATH)):
    logging.error("The provided path to the ssh privatre key is invalid: {}".format(ROBO_VACCUM_SSH_KEY_PATH))
    exit()

def message_to_url(message):
    body = {
        "engine_id": "tts.piper",
        "message": message,
        "options": {
            "voice": "en_US-libritts_r-medium"
    }
    }

    ha_request = urllib.request.Request(homeassistant_url.geturl(), data=json.dumps(body).encode('utf-8'), method='POST')
    ha_request.add_header('Authorization','Bearer {}'.format(BEARER_TOKEN))
    ha_request.add_header('Content-Type','application/json')

    audio_clip_url = None
    try:
        with urllib.request.urlopen(ha_request) as response:
            # Read and saves the url from the response
            audio_clip_url = json.loads(response.read().decode("utf-8")).get('url')
    except Exception as e:
        logging.error(f"An error occurred: {e}")
        exit()
    logging.info(audio_clip_url)
    return audio_clip_url

# Create an SSH client
client = paramiko.SSHClient()

try:
    # Automatically add the server's host key (this is insecure and should be used with caution)
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    # Load the private key
    private_key = paramiko.RSAKey(filename=ROBO_VACCUM_SSH_KEY_PATH)

    # Connect to the SSH server
    client.connect(ROBO_VACCUM_IP, 22, username='root', pkey=private_key)

    if (INTERACTIVE_MODE):
        try:
            while True:
                val = input("> ")

                # Run some commands on the server
                commands = [
                    f"wget -O {TEMP_AUDIO_FILE} {message_to_url(val)}",
                    f"aplay {TEMP_AUDIO_FILE}"
                ]

                for command in commands:
                    stdin, stdout, stderr = client.exec_command(command)
                    logging.info(f"Output of '{command}':\n{stdout.read().decode('utf-8')}")
        except KeyboardInterrupt:
            print('Exiting interactive mode')
    else:
        commands = [
            f"wget -O {TEMP_AUDIO_FILE} {message_to_url(MESSAGE)}",
            f"aplay {TEMP_AUDIO_FILE}"
        ]

        for command in commands:
            stdin, stdout, stderr = client.exec_command(command)
            logging.info(f"Output of '{command}':\n{stdout.read().decode('utf-8')}")


finally:
    # Close the SSH connection
    client.close()